/* eslint-disable */
/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism-tomorrow&languages=json */
let _self =
    typeof window !== 'undefined'
      ? window
      : typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope
      ? self
      : {},
  Prism = (function () {
    var e = /\blang(?:uage)?-([\w-]+)\b/i,
      t = 0,
      n = (_self.Prism = {
        manual: _self.Prism && _self.Prism.manual,
        disableWorkerMessageHandler:
          _self.Prism && _self.Prism.disableWorkerMessageHandler,
        util: {
          encode(e) {
            return e instanceof r
              ? new r(e.type, n.util.encode(e.content), e.alias)
              : n.util.type(e) === 'Array'
              ? e.map(n.util.encode)
              : e
                  .replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/\u00a0/g, ' ');
          },
          type(e) {
            return Object.prototype.toString
              .call(e)
              .match(/\[object (\w+)\]/)[1];
          },
          objId(e) {
            return (
              e.__id || Object.defineProperty(e, '__id', { value: ++t }), e.__id
            );
          },
          clone(e, t) {
            const r = n.util.type(e);
            switch (((t = t || {}), r)) {
              case 'Object':
                if (t[n.util.objId(e)]) {
                  return t[n.util.objId(e)];
                }
                var a = {};
                t[n.util.objId(e)] = a;
                for (const l in e) {
                  e.hasOwnProperty(l) && (a[l] = n.util.clone(e[l], t));
                }
                return a;
              case 'Array':
                if (t[n.util.objId(e)]) {
                  return t[n.util.objId(e)];
                }
                var a = [];
                return (
                  (t[n.util.objId(e)] = a),
                  e.forEach((e, r) => {
                    a[r] = n.util.clone(e, t);
                  }),
                  a
                );
            }
            return e;
          },
        },
        languages: {
          extend(e, t) {
            const r = n.util.clone(n.languages[e]);
            for (const a in t) {
              r[a] = t[a];
            }
            return r;
          },
          insertBefore(e, t, r, a) {
            a = a || n.languages;
            const l = a[e];
            if (arguments.length == 2) {
              r = arguments[1];
              for (var i in r) {
                r.hasOwnProperty(i) && (l[i] = r[i]);
              }
              return l;
            }
            const o = {};
            for (const s in l) {
              if (l.hasOwnProperty(s)) {
                if (s == t) {
                  for (var i in r) {
                    r.hasOwnProperty(i) && (o[i] = r[i]);
                  }
                }
                o[s] = l[s];
              }
            }
            const u = a[e];
            return (
              (a[e] = o),
              n.languages.DFS(n.languages, function (t, n) {
                n === u && t != e && (this[t] = o);
              }),
              o
            );
          },
          DFS(e, t, r, a) {
            a = a || {};
            for (const l in e) {
              e.hasOwnProperty(l) &&
                (t.call(e, l, e[l], r || l),
                n.util.type(e[l]) !== 'Object' || a[n.util.objId(e[l])]
                  ? n.util.type(e[l]) !== 'Array' ||
                    a[n.util.objId(e[l])] ||
                    ((a[n.util.objId(e[l])] = !0),
                    n.languages.DFS(e[l], t, l, a))
                  : ((a[n.util.objId(e[l])] = !0),
                    n.languages.DFS(e[l], t, null, a)));
            }
          },
        },
        plugins: {},
        highlightAll(e, t) {
          n.highlightAllUnder(document, e, t);
        },
        highlightAllUnder(e, t, r) {
          const a = {
            callback: r,
            selector:
              'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
          };
          n.hooks.run('before-highlightall', a);
          for (
            var l, i = a.elements || e.querySelectorAll(a.selector), o = 0;
            (l = i[o++]);

          ) {
            n.highlightElement(l, t === !0, a.callback);
          }
        },
        highlightElement(t, r, a) {
          for (var l, i, o = t; o && !e.test(o.className); ) {
            o = o.parentNode;
          }
          o &&
            ((l = (o.className.match(e) || [, ''])[1].toLowerCase()),
            (i = n.languages[l])),
            (t.className = `${t.className
              .replace(e, '')
              .replace(/\s+/g, ' ')} language-${l}`),
            t.parentNode &&
              ((o = t.parentNode),
              /pre/i.test(o.nodeName) &&
                (o.className = `${o.className
                  .replace(e, '')
                  .replace(/\s+/g, ' ')} language-${l}`));
          let s = t.textContent,
            u = { element: t, language: l, grammar: i, code: s };
          if ((n.hooks.run('before-sanity-check', u), !u.code || !u.grammar)) {
            return (
              u.code &&
                (n.hooks.run('before-highlight', u),
                (u.element.textContent = u.code),
                n.hooks.run('after-highlight', u)),
              n.hooks.run('complete', u),
              void 0
            );
          }
          if ((n.hooks.run('before-highlight', u), r && _self.Worker)) {
            const g = new Worker(n.filename);
            (g.onmessage = function (e) {
              (u.highlightedCode = e.data),
                n.hooks.run('before-insert', u),
                (u.element.innerHTML = u.highlightedCode),
                n.hooks.run('after-highlight', u),
                n.hooks.run('complete', u),
                a && a.call(u.element);
            }),
              g.postMessage(
                JSON.stringify({
                  language: u.language,
                  code: u.code,
                  immediateClose: !0,
                })
              );
          } else {
            (u.highlightedCode = n.highlight(u.code, u.grammar, u.language)),
              n.hooks.run('before-insert', u),
              (u.element.innerHTML = u.highlightedCode),
              n.hooks.run('after-highlight', u),
              n.hooks.run('complete', u),
              a && a.call(t);
          }
        },
        highlight(e, t, a) {
          const l = { code: e, grammar: t, language: a };
          return (
            n.hooks.run('before-tokenize', l),
            (l.tokens = n.tokenize(l.code, l.grammar)),
            n.hooks.run('after-tokenize', l),
            r.stringify(n.util.encode(l.tokens), l.language)
          );
        },
        matchGrammar(e, t, r, a, l, i, o) {
          const s = n.Token;
          for (const u in r) {
            if (r.hasOwnProperty(u) && r[u]) {
              if (u == o) {
                return;
              }
              let g = r[u];
              g = n.util.type(g) === 'Array' ? g : [g];
              for (let c = 0; c < g.length; ++c) {
                let h = g[c],
                  f = h.inside,
                  d = !!h.lookbehind,
                  m = !!h.greedy,
                  p = 0,
                  y = h.alias;
                if (m && !h.pattern.global) {
                  const v = h.pattern.toString().match(/[imuy]*$/)[0];
                  h.pattern = RegExp(h.pattern.source, `${v}g`);
                }
                h = h.pattern || h;
                for (let b = a, k = l; b < t.length; k += t[b].length, ++b) {
                  let w = t[b];
                  if (t.length > e.length) {
                    return;
                  }
                  if (!(w instanceof s)) {
                    if (m && b != t.length - 1) {
                      h.lastIndex = k;
                      var _ = h.exec(e);
                      if (!_) {
                        break;
                      }
                      for (
                        var j = _.index + (d ? _[1].length : 0),
                          P = _.index + _[0].length,
                          A = b,
                          x = k,
                          O = t.length;
                        O > A && (P > x || (!t[A].type && !t[A - 1].greedy));
                        ++A
                      ) {
                        (x += t[A].length), j >= x && (++b, (k = x));
                      }
                      if (t[b] instanceof s) {
                        continue;
                      }
                      (I = A - b), (w = e.slice(k, x)), (_.index -= k);
                    } else {
                      h.lastIndex = 0;
                      var _ = h.exec(w),
                        I = 1;
                    }
                    if (_) {
                      d && (p = _[1] ? _[1].length : 0);
                      var j = _.index + p,
                        _ = _[0].slice(p),
                        P = j + _.length,
                        N = w.slice(0, j),
                        S = w.slice(P),
                        C = [b, I];
                      N && (++b, (k += N.length), C.push(N));
                      const E = new s(u, f ? n.tokenize(_, f) : _, y, _, m);
                      if (
                        (C.push(E),
                        S && C.push(S),
                        Array.prototype.splice.apply(t, C),
                        I != 1 && n.matchGrammar(e, t, r, b, k, !0, u),
                        i)
                      ) {
                        break;
                      }
                    } else if (i) {
                      break;
                    }
                  }
                }
              }
            }
          }
        },
        tokenize(e, t) {
          let r = [e],
            a = t.rest;
          if (a) {
            for (const l in a) {
              t[l] = a[l];
            }
            delete t.rest;
          }
          return n.matchGrammar(e, r, t, 0, 0, !1), r;
        },
        hooks: {
          all: {},
          add(e, t) {
            const r = n.hooks.all;
            (r[e] = r[e] || []), r[e].push(t);
          },
          run(e, t) {
            const r = n.hooks.all[e];
            if (r && r.length) {
              for (var a, l = 0; (a = r[l++]); ) {
                a(t);
              }
            }
          },
        },
      }),
      r = (n.Token = function (e, t, n, r, a) {
        (this.type = e),
          (this.content = t),
          (this.alias = n),
          (this.length = 0 | (r || '').length),
          (this.greedy = !!a);
      });
    if (
      ((r.stringify = function (e, t, a) {
        if (typeof e === 'string') {
          return e;
        }
        if (n.util.type(e) === 'Array') {
          return e
            .map((n) => {
              return r.stringify(n, t, e);
            })
            .join('');
        }
        const l = {
          type: e.type,
          content: r.stringify(e.content, t, a),
          tag: 'span',
          classes: ['token', e.type],
          attributes: {},
          language: t,
          parent: a,
        };
        if (e.alias) {
          const i = n.util.type(e.alias) === 'Array' ? e.alias : [e.alias];
          Array.prototype.push.apply(l.classes, i);
        }
        n.hooks.run('wrap', l);
        const o = Object.keys(l.attributes)
          .map((e) => {
            return `${e}="${(l.attributes[e] || '').replace(/"/g, '&quot;')}"`;
          })
          .join(' ');
        return `<${l.tag} class="${l.classes.join(' ')}"${o ? ` ${o}` : ''}>${
          l.content
        }</${l.tag}>`;
      }),
      !_self.document)
    ) {
      return _self.addEventListener
        ? (n.disableWorkerMessageHandler ||
            _self.addEventListener(
              'message',
              (e) => {
                let t = JSON.parse(e.data),
                  r = t.language,
                  a = t.code,
                  l = t.immediateClose;
                _self.postMessage(n.highlight(a, n.languages[r], r)),
                  l && _self.close();
              },
              !1
            ),
          _self.Prism)
        : _self.Prism;
    }
    const a =
      document.currentScript ||
      [].slice.call(document.getElementsByTagName('script')).pop();
    return (
      a &&
        ((n.filename = a.src),
        n.manual ||
          a.hasAttribute('data-manual') ||
          (document.readyState !== 'loading'
            ? window.requestAnimationFrame
              ? window.requestAnimationFrame(n.highlightAll)
              : window.setTimeout(n.highlightAll, 16)
            : document.addEventListener('DOMContentLoaded', n.highlightAll))),
      _self.Prism
    );
  })();
typeof module !== 'undefined' && module.exports && (module.exports = Prism),
  typeof global !== 'undefined' && (global.Prism = Prism);
(Prism.languages.json = {
  comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
  property: { pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, greedy: !0 },
  string: { pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, greedy: !0 },
  number: /-?\d+\.?\d*(e[+-]?\d+)?/i,
  punctuation: /[{}[\],]/,
  operator: /:/,
  boolean: /\b(?:true|false)\b/,
  null: /\bnull\b/,
}),
  (Prism.languages.jsonp = Prism.languages.json);
export default Prism;
